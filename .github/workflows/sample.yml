name: Download package.json files

on:
  workflow_dispatch:
    inputs:
      repo:
        description: "Repo Name"
        required: true

env:
  REPO: ${{ github.event.inputs.repo }}        

jobs:
  download-package-json:
    runs-on: ubuntu-latest

    steps:
      - name: Sparse checkout another repo
        run: |
          git clone --no-checkout https://github.com/Sunilsindur/$REPO remote-repo
          cd remote-repo
          git sparse-checkout init --cone
          echo "*package.json" >> .git/info/sparse-checkout
          echo "*demo.json" >> .git/info/sparse-checkout
          git checkout

      - name: bash script to copy package.json files or demo.json files with there dir name
        run: |
          mkdir -p ../json-files
          find . -type f \( -name "package.json" -o -name "demo.json" \) -exec bash -c 'mkdir -p ../json-files/$(dirname "{}"); cp "{}" ../json-files/$(dirname "{}")' \;

      - name: display directories name and content of files
        run: |
          cd ../json-files
          echo "Folders containing package.json or demo.json files and their contents:"
          find . -type f \( -name "package.json" -o -name "demo.json" \) | while read file; do
            # folder_name=$(basename "$(dirname "$file")")
            # echo "------------------------------------------"
            # echo "Folder: $folder_name"
            # echo "Contents of $file:"
            # cat "$file"
            # echo "------------------------------------------"
            
            #!/bin/bash

          # Define the component name and other static fields
          COMPONENT_NAME="electron"
          SOURCE="GitHub"
          STAGE="DEV"
          MEASURE_NAME="Component Dependencies"
          
          # Read the package.json file and extract dependencies and versions using jq
          DEPENDENCIES=$(jq '.devDependencies' package.json)
          
          # Create an empty JSON array to store the formatted result
          RESULT_JSON="[]"
          
          # Loop through each dependency and format it into the desired structure
          for DEP in $(echo "$DEPENDENCIES" | jq -r 'keys[]'); do
            VERSION=$(echo "$DEPENDENCIES" | jq -r --arg dep "$DEP" '.[$dep]')
            
            # Create the dependency JSON object
            DEP_JSON=$(jq -n \
              --arg dep "$DEP" \
              --arg ver "$VERSION" \
              '{"dependencyName": $dep, "version": $ver}')
          
            # Add the dependency to the result array
            RESULT_JSON=$(echo "$RESULT_JSON" | jq --argjson dep "$DEP_JSON" '. + [$dep]')
          done
          
          # Wrap the dependencies in the final object structure
          FINAL_JSON=$(jq -n \
            --arg comp "$COMPONENT_NAME" \
            --arg src "$SOURCE" \
            --arg stage "$STAGE" \
            --arg meas "$MEASURE_NAME" \
            --argjson data "$RESULT_JSON" \
            '[{
              "componentName": $comp,
              "source": $src,
              "stage": $stage,
              "measures": [{
                "measureName": $meas,
                "data": $data
              }]
            }]')
          
          # Output the final JSON
          echo "$FINAL_JSON"

          done
        

          



          
